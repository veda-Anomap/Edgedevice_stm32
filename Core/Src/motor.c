/* servo_mg90s.c
 *
 * Target: NUCLEO-F401RE + MG90S(servo)
 * PWM pin recommendation: PA6 = TIM3_CH1 (Arduino D12 on Nucleo-64 header)
 *
 * Prerequisite (CubeMX):
 * - Enable TIM3 Channel1 as "PWM Generation CH1"
 * - Set TIM3 to 50Hz with 1us tick:
 *     TIMCLK (TIM3) typically 84MHz when SYSCLK=84MHz, but can differ.
 *     Prescaler (PSC) = (TIMCLK / 1,000,000) - 1   => 1 MHz timer tick (1us)
 *     Period (ARR)    = 20000 - 1                  => 20ms period (50Hz)
 *     Pulse (CCR1)    = 1500                       => center
 *
 * Wiring:
 * - MG90S GND(brown)  -> Nucleo GND
 * - MG90S VCC(red)   -> External 5V (recommended), NOT from 3.3V
 * - MG90S SIG(orange)-> PA6 (TIM3_CH1)
 * - External 5V GND must be common with Nucleo GND
 */

#include "main.h"
#include <stdint.h>

/* ===== User config (change if you chose a different timer/channel) ===== */
extern TIM_HandleTypeDef htim3;              // Generated by CubeMX
#define SERVO_TIM            htim3
#define SERVO_TIM_CHANNEL    TIM_CHANNEL_1   // TIM3_CH1 -> PA6
/* ===================================================================== */

#define SERVO_PERIOD_US      20000u          // 20ms
#define SERVO_MIN_US         1000u
#define SERVO_MAX_US         2000u
#define SERVO_CENTER_US      1500u

static uint8_t s_started = 0;

/* Clamp helper */
static uint16_t clamp_u16(uint16_t v, uint16_t lo, uint16_t hi)
{
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
}

/* Start PWM and move to center */
void Servo_Init(void)
{
    if (!s_started)
    {
        HAL_TIM_PWM_Start(&SERVO_TIM, SERVO_TIM_CHANNEL);
        s_started = 1;
    }
    /* Center position */
    __HAL_TIM_SET_COMPARE(&SERVO_TIM, SERVO_TIM_CHANNEL, SERVO_CENTER_US);
}

/* Set pulse width in microseconds (typ: 1000~2000us) */
void Servo_WriteMicroseconds(uint16_t us)
{
    us = clamp_u16(us, SERVO_MIN_US, SERVO_MAX_US);

    if (!s_started)
    {
        HAL_TIM_PWM_Start(&SERVO_TIM, SERVO_TIM_CHANNEL);
        s_started = 1;
    }
    __HAL_TIM_SET_COMPARE(&SERVO_TIM, SERVO_TIM_CHANNEL, us);
}

/* Set angle 0~180 (linear mapping 1000~2000us) */
void Servo_WriteAngle(uint8_t angle_deg)
{
    if (angle_deg > 180u) angle_deg = 180u;

    /* 0->1000us, 180->2000us */
    uint16_t us = (uint16_t)(SERVO_MIN_US + ((uint32_t)angle_deg * (SERVO_MAX_US - SERVO_MIN_US)) / 180u);
    Servo_WriteMicroseconds(us);
}

/* Simple left-center-right-center demo (blocking) */
void Servo_DemoSweepBlocking(void)
{
    Servo_Init();

    while (1)
    {
        Servo_WriteMicroseconds(SERVO_MIN_US);   // left
        HAL_Delay(700);

        Servo_WriteMicroseconds(SERVO_CENTER_US); // center
        HAL_Delay(400);

        Servo_WriteMicroseconds(SERVO_MAX_US);   // right
        HAL_Delay(700);

        Servo_WriteMicroseconds(SERVO_CENTER_US); // center
        HAL_Delay(400);
    }
}

/* Optional: stop PWM output (servo will not actively hold position) */
void Servo_Deinit(void)
{
    if (s_started)
    {
        HAL_TIM_PWM_Stop(&SERVO_TIM, SERVO_TIM_CHANNEL);
        s_started = 0;
    }
}

/* ===== Example usage (put this in main.c) =====
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_TIM3_Init(); // CubeMX generated

    Servo_DemoSweepBlocking(); // never returns
}
*/
